# -*- mode: sh -*-

##############################################################################->
# Common aliases
#
alias d="cd ~/Dropbox"
alias o='open . &'
alias ogc='google-chrome '
alias more='less'
alias chx='chmod +x'
alias reload='. ~/.bash_profile'
alias start="gnome-open"
alias open="gnome-open"
alias cl='clear; l'
# Color aliases
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
# Super user
alias _='sudo'
alias ss='sudo su -'
# Show history
alias history='fc -l 1'
alias h='history'
# Emacs
alias et='emacsclient.emacs23 -nw'
alias em=emacsclient.emacs23
# apt-get
alias sagi='sudo apt-get install'
alias agi='apt-get install'
alias e='exit'
alias k9="killall -9"
# Processes
alias tu='top -p cpu' # cpu
alias tm='top -p vsize' # memory
# List Pids using IPs
alias pidips='sudo lsof -iTCP -sTCP:LISTEN -P'
#heroku helpers
alias hp="git push heroku master"
alias hl="heroku logs"
#
##############################################################################<-

##############################################################################->
# File - Directory Operations
#
alias srm='sudo rm'
alias la="ls -A -l -G"
alias lag='la | grep'
alias lg='la | grep'
alias md='mkdir -p'
alias rd='rm -rf'
alias rd*='rm -fr *'
alias l.='ls -d .[^.]*'
# -G color -l long listing, most recent first
alias l='ls -lhGt'
alias lh="ls -lh"
# -l long listing, human readable, no group info
alias ll='ls -lhG'
# sort with recently modified first
alias lt='ls -lt'
alias md='mkdir -p'
alias lsa='ls -lah'
alias l='ls -la'
alias ll='ls -alr'
alias space2us='find . -type f | while read i;do [ "$i" != "${i// /_}" ] && mv "$i" "${i// /_}" ;done'
# Install a .tar.gz archive in current directory
tardir() {
  if [ $# != 0 ]; then tar zxvf $1; fi
}

# List the contents of a .zip archive
cz() {
  if [ $# != 0 ]; then unzip -l $*; fi
}

# List the contents of a .tar.gz archive
ctgz() {
  for file in $* ; do
    tar ztf ${file}
  done
}

# Create a .tgz archive a la zip.
tgz() {
  if [ $# != 0 ]; then
    name=$1.tar; shift; tar -rvf ${name} $* ; gzip -9 ${name}
  fi
}

function rmf(){
    for file in $*
    do
        __rm_single_file $file
    done
}

function zipr() {
  zip -r $1.zip $1
}

function __rm_single_file(){
    if ! [ -d ~/.Trash/ ]
    then
        command /bin/mkdir ~/.Trash
    fi

    if ! [ $# -eq 1 ]
    then
        echo "__rm_single_file: 1 argument required but $# passed."
        exit
    fi

    if [ -e $1 ]
    then
        BASENAME=`basename $1`
        NAME=$BASENAME
        COUNT=0
        while [ -e ~/.Trash/$NAME ]
        do
            COUNT=$(($COUNT+1))
            NAME="$BASENAME.$COUNT"
        done

        command /bin/mv $1 ~/.Trash/$NAME
    else
        echo "No such file or directory: $file"
    fi
}
#
##############################################################################<-

##############################################################################->
# changing directory to code project
#
alias gt-e='cd ~/.emacs.d && la'
alias gt-m='cd ~/.my-precious && la'
alias gt-d='cd ~/Dropbox && la'
alias 1='cd -'
alias 2='cd +2'
alias 3='cd +3'
alias 4='cd +4'
alias 5='cd +5'
alias 6='cd +6'
alias 7='cd +7'
alias 8='cd +8'
alias 9='cd +9'
alias ..='cd ..'

function c { cd ~/code/$1; }
#
##############################################################################<-

##############################################################################->
# Servers - Misc
#
# Nginx
function nginx_stop() {
    ps ax | grep nginx | cut -d " " -f 1 | xargs sudo kill -9
}
function nginx_start() {
    sudo /opt/nginx/sbin/nginx
}
#
##############################################################################<-

##############################################################################->
# Git Aliases
#
alias ungit="find . -name '.git' -exec rm -rf {} \;"
alias g='git'
alias ga='git add'
alias ga.='git add .'
alias gap='git add -p'
alias gb='git branch'
alias gba='git branch -a'
alias gc='git commit -v'
alias gca='git commit -v -a'
alias gck='git checkout'
alias gcp='git cherry-pick'
alias gco="git checkout"
alias gcop="git checkout -p"
alias gcount='git shortlog -sn'
alias gd='git diff'
alias gdh='git diff HEAD'
alias gdm='git diff master'
alias gds='git diff --cached'
alias gdv='git diff -w "$@" | vim -R -'
alias gl='git pull'
alias glp='gl -p'
alias gi='git init && printf "log/\nThumbs.db\n" >> .gitignore && git add .gitignore'
alias gitx='gitx --all'
alias gnp="git-notpushed"
alias gp='git push'
alias gpr='git pull --rebase || (notify "pull failed" "Git" && false)'
alias gpru='gp && rake && gu'
alias gri='git rebase -i origin/master^'
alias grc='git rebase --continue'
alias gst='git status'
alias gup='git fetch && git rebase'
alias gu='git push origin HEAD || (notify "push failed" "Git" && false)'

# http://www.jukie.net/~bart/blog/pimping-out-git-log
alias gitl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%an %cr)%Creset' --abbrev-commit --date=relative"

# complete -o default -o nospace -F _git_branch gb

# Commit pending changes and quote all args as message
function gg() {
    git commit -v -a -m "$*"
}

# Setup a tracking branch from [remote] [branch_name]
function gbt() {
  git branch --track $2 $1/$2 && git checkout $2
}
# Quickly clobber a file and checkout
function grf() {
  rm $1
  git checkout $1
}

# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

# Git clone from GitHub
function gch() {
  git clone git://github.com/$1/$2.git
}

ggc() {
  set -- `du -ks`
  before=$1
  git reflog expire --expire=1.minute refs/heads/master && git fsck --unreachable && git prune && git gc
  set -- `du -ks`
  after=$1
  echo "Cleaned up $((before-after)) kb."
}

grb() {
  git push origin HEAD:refs/heads/$1
  git fetch origin &&
  git checkout -b $1 --track origin/$1
}

current_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

git_commits_ahead() {
  git status 2> /dev/null | grep ahead | sed -e 's/.*by \([0-9]\{1,\}\) commits\{0,1\}\./\1/'
}

# Roughly from git_completion
git_dirty_state() {
  local w
  w=''
  local g="$(__gitdir)"
  if [ -n "$g" ]; then
    git diff --no-ext-diff --quiet --exit-code || w="+"
    if git rev-parse --quiet --verify HEAD >/dev/null; then
      git diff-index --cached --quiet HEAD -- || w="+"
    fi
  fi
  echo -n $w
}

git_modifications() {
  wrap_unless_empty "`git_commits_ahead`" "`git_dirty_state`"
}
wrap_unless_empty() {
  if [ -n "$1" ] || [ -n "$2" ] || [ -n "$3" ] || [ -n "$4" ]; then
    echo -n "($1$2$3$4)"
  fi
}

# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

parse_git_dirty () {
  if [[ $((git status 2> /dev/null) | tail -n1) != "nothing to commit (working directory clean)" ]]; then
    echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
  else
    echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
  fi
}

#
# Will return the current branch name
# Usage example: git pull origin $(current_branch)
#
function current_branch() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo ${ref#refs/heads/}
}

# get the name of the branch we are on
function git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
}
#
##############################################################################<-

##############################################################################->
# General helpers
#
# Regenerate TAGS file from file arguments
function ct() {
  rm -f TAGS
  etags --append --output=TAGS $*
}

# Setup a tunnel
function haproxyssh() {
  ssh -L7997:127.0.0.1:7997 deploy@$1.com
}

# Syntax check Javascript
function jsc() {
  jsl -conf /etc/jsl/jsl.conf -process $1
}

function legrep {
  egrep --color=yes "$@" | less -R
}

myip() {
  curl --silent 'www.whatismyip.com/automation/n09230945.asp' && echo
}

_ssh_hosts() {
  grep "Host " ~/.ssh/config 2> /dev/null | sed -e "s/Host //g"
  # http://news.ycombinator.com/item?id=751220
  cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["
}
complete -W "$(_ssh_hosts)" ssh
#
##############################################################################<-
