# -*- mode: sh -*-
##############################################################################->
# Common aliases
alias o='open . &'
alias chrome='google-chrome '
alias more='less'
alias chx='chmod +x'
alias reload='. ~/.bash_profile'
alias open="gnome-open"
alias cl='clear'
# Color aliases
alias ls='ls --color=auto'
# Super user
alias _='sudo'
alias ss='sudo su -'
# Show history
alias history='fc -l 1'
alias h='history'
# Emacs
function em { emacs -Q -nw "$1"; }
function sem { sudo emacs -Q -nw "$1"; }
alias em_aliases='em ~/.my-precious/bash/aliases'
alias em_config='em ~/.my-precious/bash/config'
alias em_init='em ~/.emacs.d/init.el'
# apt-get
alias sagi='sudo apt-get install'
alias agi='apt-get install'
alias k9="killall -9"
# Pids IPs
alias pidips='sudo lsof -iTCP -sTCP:LISTEN -P'
# heroku
alias hp="git push heroku master"
alias hl="heroku logs"
alias tmp_test='cd ~/tmp && mkdir whatever && cd whatever'
# disk usage with human sizes and minimal depth
alias du1='du -h --max-depth=1'
alias fn='find . -name'
alias hi='history | tail -20'
alias boxfs='sudo sysctl fs.inotify.max_user_watches=100000'
# Browse
function br-gh { ogc "https://github.com/$1"; }
function br-t { ogc "https://twitter.com/$1"; }
function br-g { ogc "http://www.google.com/search?q=$1"; }
# cding...
alias ..='cd ..'
function e { cd ~/.emacs.d/$1 && ls --format=long; }
function m { cd ~/.my-precious/$1 && ls --format=long; }
function d { cd ~/Dropbox/$1 && ls --format=long; }
function t { cd ~/todo/$1 && ls --format=long; }
function c { cd ~/code/$1 && ls --format=long; }
function tmp { cd ~/tmp/$1 && ls --format=long; }
function yas { cd ~/.emacs.d/vendor/snippets/yasnippets-jpablobr/$1 && ls --format=long; }

##############################################################################->
# Grep
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias gp_l='l | grep'
alias gp_la='la | grep'
function g_. { grep -nH -e "$@";}
function gp_aliases { grep -nH -e "$@" ~/.my-precious/bash/aliases; }
function gp_linux_yac { grep -nH -e "$@" ~/org/yacs/linux.org; }
function less_gp { egrep --color=yes "$@" | less -R; }
function find_gp { find "$1" -type f -print0 | xargs -0 -e grep -nH -e "$2"; }

##############################################################################->
# File - Directory Operations
alias srm='sudo rm'
alias md='mkdir -p'
alias rd='rm -rf'
alias rd*='rm -fr *'
alias l.='ls -d .[^.]*'
# -G color -l long listing, most recent first
alias l='ls -lhGt'
alias lh="ls -lh"
alias lsa='ls -lah'
alias la='ls --format=long'
# sort with recently modified first
alias lt='ls -lt'
alias md='mkdir -p'
alias dir='ls --format=vertical'
alias space2us='find . -depth -exec ~/bin/rename_files_with_spaces {} \;'

# Open all files by given pattern.
function for_open {
    for file in "$1"; do
        open $file;
    done
}

# Install a .tar.gz archive in current directory
tardir() {
  if [ $# != 0 ]; then tar zxvf $1; fi
}

# List the contents of a .zip archive
cz() {
  if [ $# != 0 ]; then unzip -l $*; fi
}

# List the contents of a .tar.gz archive
ctgz() {
  for file in $* ; do
    tar ztf ${file}
  done
}

# Create a .tgz archive a la zip.
tgz() {
  if [ $# != 0 ]; then
    name=$1.tar; shift; tar -rvf ${name} $* ; gzip -9 ${name}
  fi
}

function rmf(){
    for file in $*
    do
        __rm_single_file $file
    done
}

function zipr() {
  zip -r $1.zip $1
}

function __rm_single_file(){
    if ! [ -d ~/.Trash/ ]
    then
        command /bin/mkdir ~/.Trash
    fi

    if ! [ $# -eq 1 ]
    then
        echo "__rm_single_file: 1 argument required but $# passed."
        exit
    fi

    if [ -e $1 ]
    then
        BASENAME=`basename $1`
        NAME=$BASENAME
        COUNT=0
        while [ -e ~/.Trash/$NAME ]
        do
            COUNT=$(($COUNT+1))
            NAME="$BASENAME.$COUNT"
        done

        command /bin/mv $1 ~/.Trash/$NAME
    else
        echo "No such file or directory: $file"
    fi
}

##############################################################################->
# Servers - Misc
function nginx_stop() {
    ps ax | grep nginx | cut -d " " -f 1 | xargs sudo kill -9
}
function nginx_start() {
    sudo /opt/nginx/sbin/nginx
}

##############################################################################->
# Git Aliases
alias ungit="find . -name '.git' -exec rm -rf {} \;"
alias g='git'
alias ga='git add'
alias ga.='git add .'
alias gbox='cd ~/Dropbox && git add . && gg updates and backup && gp && cd -'
alias gap='git add -p'
alias gb='git branch'
alias gba='git branch -a'
alias gca='git commit -v -a'
alias gck='git checkout'
alias gcp='git cherry-pick'
alias gco="git checkout"
alias gcop="git checkout -p"
alias gcount='git shortlog -sn'
alias gd='git diff'
alias gdh='git diff HEAD'
alias gdm='git diff master'
alias gds='git diff --cached'
alias gdv='git diff -w "$@" | vim -R -'
alias gl='git pull'
alias glp='gl -p'
alias gi='git init && printf "log/\nThumbs.db\n" >> .gitignore && git add .gitignore'
alias gitx='gitx --all'
alias gnp="git-notpushed"
alias gp='git push'
alias gpr='git pull --rebase || (notify "pull failed" "Git" && false)'
alias gpru='gp && rake && gu'
alias gri='git rebase -i origin/master^'
alias grc='git rebase --continue'
alias gup='git fetch && git rebase'
alias gu='git push origin HEAD || (notify "push failed" "Git" && false)'

# http://www.jukie.net/~bart/blog/pimping-out-git-log
alias gitl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%an %cr)%Creset' --abbrev-commit --date=relative"

# Commit pending changes and quote all args as message
function gg() {
    git commit -v -a -m "$*"
}

function gc() {
    git add . && git commit -v -a -m "$*" && gst
}

# Setup a tracking branch from [remote] [branch_name]
function gbt() {
  git branch --track $2 $1/$2 && git checkout $2
}
# Quickly clobber a file and checkout
function grf() {
  rm $1
  git checkout $1
}

# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

# Git clone from GitHub
function gch() {
  git clone git://github.com/$1/$2.git
}

ggc() {
  set -- `du -ks`
  before=$1
  git reflog expire --expire=1.minute refs/heads/master && git fsck --unreachable && git prune && git gc
  set -- `du -ks`
  after=$1
  echo "Cleaned up $((before-after)) kb."
}

grb() {
  git push origin HEAD:refs/heads/$1
  git fetch origin &&
  git checkout -b $1 --track origin/$1
}

current_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

git_commits_ahead() {
  git status 2> /dev/null | grep ahead | sed -e 's/.*by \([0-9]\{1,\}\) commits\{0,1\}\./\1/'
}

# Roughly from git_completion
git_dirty_state() {
  local w
  w=''
  local g="$(__gitdir)"
  if [ -n "$g" ]; then
    git diff --no-ext-diff --quiet --exit-code || w="+"
    if git rev-parse --quiet --verify HEAD >/dev/null; then
      git diff-index --cached --quiet HEAD -- || w="+"
    fi
  fi
  echo -n $w
}

git_modifications() {
  wrap_unless_empty "`git_commits_ahead`" "`git_dirty_state`"
}
wrap_unless_empty() {
  if [ -n "$1" ] || [ -n "$2" ] || [ -n "$3" ] || [ -n "$4" ]; then
    echo -n "($1$2$3$4)"
  fi
}

# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
  ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
  git remote add origin git@example.com:$1.git
  git push origin master
  git config branch.master.remote origin
  git config branch.master.merge refs/heads/master
  git config push.default current
}

parse_git_dirty () {
  if [[ $((git status 2> /dev/null) | tail -n1) != "nothing to commit (working directory clean)" ]]; then
    echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
  else
    echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
  fi
}

# Will return the current branch name
# Usage example: git pull origin $(current_branch)
function current_branch() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo ${ref#refs/heads/}
}

# get the name of the branch we are on
function git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
}

##############################################################################->
# General helpers
# Regenerate TAGS file from file arguments
function ct() {
  rm -f TAGS
  etags --append --output=TAGS $*
}

# Setup a tunnel
function haproxyssh() {
  ssh -L7997:127.0.0.1:7997 deploy@$1.com
}

# Syntax check Javascript
function jsc() {
  jsl -conf /etc/jsl/jsl.conf -process $1
}

myip() {
  curl --silent 'www.whatismyip.com/automation/n09230945.asp' && echo
}

_ssh_hosts() {
  grep "Host " ~/.ssh/config 2> /dev/null | sed -e "s/Host //g"
  # http://news.ycombinator.com/item?id=751220
  cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["
}
complete -W "$(_ssh_hosts)" ssh