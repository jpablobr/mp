#!/bin/bash

# the basics
: ${HOME=~}
: ${LOGNAME=$(id -un)}
: ${UNAME=$(uname)}

# complete hostnames from this file
: ${HOSTFILE=$HOME/.ssh/known_hosts}
: ${HOSTNAME=$(/bin/hostname)}
# readline config
: ${INPUTRC=~/.inputrc}

# ----------------------------------------------------------------------
# - SHELL OPTIONS:

# Emacs mode
set -o emacs

# bring in system bashrc
test -r /etc/bashrc &&
. /etc/bashrc

# notify of bg job completion immediately
set -o notify

# shell opts. see bash(1) for details
shopt -s cdspell >/dev/null 2>&1
shopt -s extglob >/dev/null 2>&1
shopt -s histappend >/dev/null 2>&1
shopt -s hostcomplete >/dev/null 2>&1
shopt -s interactive_comments >/dev/null 2>&1
shopt -u mailwarn >/dev/null 2>&1
shopt -s no_empty_cmd_completion  >/dev/null 2>&1
shopt -s dotglob >/dev/null 2>&1
shopt -s expand_aliases >/dev/null 2>&1
shopt -s huponexit >/dev/null 2>&1
shopt -s interactive_comments >/dev/null 2>&1

# fuck that you have new mail shit
unset MAILCHECK

# disable core dumps
ulimit -S -c 0

# default umask
umask 0022

# ----------------------------------------------------------------------
# - PATH:

JAVA_HOME=/usr/lib/jvm/java-6-sun/
export JAVA_HOME
export CLASSPATH=.:/usr/share/java/junit.jar

export CPATH=$CPATH:/usr/include/gtk-2.0
export CPATH=$CPATH:/usr/include/glib-2.0/
export CPATH=$CPATH:/usr/lib/glib-2.0/include/
export CPATH=$CPATH:/usr/include/pango-1.0/
export CPATH=$CPATH:/usr/lib/gtk-2.0/include/
export CPATH=$CPATH:/usr/include/atk-1.0/

# bin
PATH="/bin:/usr/bin:/usr/local/bin:$PATH"
PATH="$JAVA_HOME/bin:$PATH"

# sbin
PATH="/usr/local/sbin:/usr/sbin:/sbin:$PATH"

# if ~/bin.
test -d "$HOME/bin" &&
PATH="$HOME/bin:$PATH"

# if ~/bin/ruby.
test -d "$HOME/bin/ruby" &&
PATH="$HOME/bin/ruby:$PATH"

# if Haskell
test -d "$HOME/.cabal/bin" &&
PATH="$HOME/.cabal/bin:$PATH"

# if node.js.
test -d "$HOME/local/node/bin" &&
PATH="$HOME/local/node/bin:$PATH"

test -d "/usr/local/texlive/2010/bin/x86_64-linux" &&
PATH="/usr/local/texlive/2010/bin/x86_64-linux:$PATH"

# if RVM.
test -s  "$HOME/.rvm/scripts/rvm" &&
source "$HOME/.rvm/scripts/rvm"

# tmuxinator
test -s "$HOME/.tmuxinator/scripts/tmuxinator" &&
source "$HOME/.tmuxinator/scripts/tmuxinator"

# if bashmarks
test -f "$HOME/bin/bashmarks.sh" &&
source "$HOME/bin/bashmarks.sh"

# if Aliases
test -f "$HOME/.my-precious/bash/aliases" &&
source "$HOME/.my-precious/bash/aliases"

# if SSH
test -f "$HOME/.ssh/environment" &&
export SSH_ENV="$HOME/.ssh/environment"

# ----------------------------------------------------------------------
# - ENVIRONMENT CONFIGURATION:

# detect interactive shell
case "$-" in
    *i*) INTERACTIVE=yes ;;
    *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
    -*) LOGIN=yes ;;
    *)  unset LOGIN ;;
esac

# enable en_US locale w/ utf-8 encodings if not already configured
# : ${LANG:="en_US.UTF-8"}
# : ${LANGUAGE:="en"}
# : ${LC_CTYPE:="en_US.UTF-8"}
# : ${LC_ALL:="en_US.UTF-8"}
# export LANG LANGUAGE LC_CTYPE LC_ALL

# always use PASSIVE mode ftp
: ${FTP_PASSIVE:=1}
export FTP_PASSIVE

# ignore backups, CVS directories, python bytecode, vim swap files
FIGNORE="~:CVS:#:.pyc:.swp:.swa:apache-solr-*"

# history stuff
HISTCONTROL=ignoreboth
HISTFILESIZE=10000
HISTSIZE=1000
BIBINPUTS=.:/usr/share/texmf-texlive/bibtex
TEXINPUTS=.:/usr/share/texmf-texlive/tex/

# rip config
RIPDIR=/home/jpablobr/.rip
RUBYLIB="$RUBYLIB:$RIPDIR/active/lib"
PATH="$PATH:$RIPDIR/active/bin"
export RIPDIR RUBYLIB PATH

# Autotest
# export AUTOFEATURE=true

# ----------------------------------------------------------------------
# - PAGER / EDITOR:

# Get color support for 'less'
# --max-forw-scroll=4 --max-back-scroll=4"
export LESS="--RAW-CONTROL-CHARS --shift 4"
export LESSOPEN="|lesspipe.sh %s"
export LESS_TERMCAP_mb='[01;31m'
export LESS_TERMCAP_md='[01;34m'
export LESS_TERMCAP_me='[0m'
export LESS_TERMCAP_se='[0m'
export LESS_TERMCAP_so='[01;44;37m'
export LESS_TERMCAP_ue='[0m'
export LESS_TERMCAP_us='[01;37m'

HAVE_EMACS=$(command -v emacs)

# EDITOR
test -n "$HAVE_EMACS" &&
export VISUAL='emacs -Q -nw' &&
export EDITOR='emacs -Q -nw'

# PAGER
if test -n "$(command -v less)" ; then
    PAGER="less -FirSwX"
    MANPAGER="less -FiRswX"
else
    PAGER=more
    MANPAGER="$PAGER"
fi

# Ack
export ACK_PAGER="$PAGER"
export ACK_PAGER_COLOR="$PAGER"

export GEM_EDITOR=$EDITOR

# ----------------------------------------------------------------------
# - Source functions Dir:

: ${MY_PRECIOUS_FUNCTIONS_DIR:=$HOME/.my-precious/bash/functions}

test -n "$MY_PRECIOUS_FUNCTIONS_DIR" && {
  if [ -d $MY_PRECIOUS_FUNCTIONS_DIR -a -r $MY_PRECIOUS_FUNCTIONS_DIR -a \
       -x $MY_PRECIOUS_FUNCTIONS_DIR ]; then
    for i in $MY_PRECIOUS_FUNCTIONS_DIR/*; do
      [[ ${i##*/} != @(*~|*.bak|*.swp|\#*\#|*.dpkg*|.rpm*) ]] &&
      [ \( -f $i -o -h $i \) -a -r $i ] && . $i
    done
  fi
  unset i
}

# ----------------------------------------------------------------------
# - BASH COMPLETION:

test -z "$BASH_COMPLETION" && {
    bash=${BASH_VERSION%.*}; bmajor=${bash%.*}; bminor=${bash#*.}
    test -n "$PS1" && test $bmajor -gt 1 && {
        # search for a bash_completion file to source
        for f in /usr/local/etc/bash_completion \
            /usr/pkg/etc/bash_completion \
            /opt/local/etc/bash_completion \
            /etc/bash_completion
        do
            test -f $f && {
                . $f
                break
            }
        done
    }
    unset bash bmajor bminor
}

: ${USER_BASH_COMPLETION_DIR:=$HOME/bin/completions}

test -n "$USER_BASH_COMPLETION_DIR" && {
  # source completion directory definitions
  if [ -d $USER_BASH_COMPLETION_DIR -a -r $USER_BASH_COMPLETION_DIR -a \
       -x $USER_BASH_COMPLETION_DIR ]; then
    for i in $USER_BASH_COMPLETION_DIR/*; do
      [[ ${i##*/} != @(*~|*.bak|*.swp|\#*\#|*.dpkg*|.rpm*) ]] &&
      [ \( -f $i -o -h $i \) -a -r $i ] && . $i
    done
  fi
  unset i
}

# override and disable tilde expansion
_expand() {
    return 0
}

test -f ~/.ssh/known_hosts && {
    _ssh_hosts() {
        grep "Host " ~/.ssh/config 2> /dev/null | sed -e "s/Host //g"
        # http://news.ycombinator.com/item?id=751220
        cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["
    }
    complete -W "$(_ssh_hosts)" ssh
}
# ----------------------------------------------------------------------
# - LS AND DIRCOLORS:

# if the dircolors utility is available, set that up to
dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$dircolors" && {
    COLORS=/etc/DIR_COLORS
    test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
    test -e "$HOME/.dircolors"        && COLORS="$HOME/.dircolors"
    test ! -e "$COLORS"               && COLORS=
    eval `dircolors --sh $COLORS`
}

export TERM=xterm-color
export GREP_OPTIONS='--color=auto' GREP_COLOR='1;32'
export CLICOLOR=1
unset dircolors
export LS_OPTIONS='-s -F -T 0 --color=yes'

# use gem-man(1) if available:
man () {
    gem man -s "$@" 2>/dev/null ||
    command man "$@"
}

# -------------------------------------------------------------------
# - USER SHELL ENVIRONMENT:

# bring in rbdev functions
. rbdev 2>/dev/null || true

# source ~/.shenv now if it exists
test -r ~/.shenv &&
. ~/.shenv

# condense PATH entries
PATH=$(puniq $PATH)
MANPATH=$(puniq $MANPATH)

# -------------------------------------------------------------------
# - MOTD / FORTUNE:
test -n "$INTERACTIVE" -a -n "$LOGIN" && {
    uname -npsr
    uptime
}

# ----------------------------------------------------------------------
# - PROMP:

GREEN="\[\033[0;32m\]"
RED="\[\033[0;31m\]"
BROWN="\[\033[0;33m\]"
GREY="\[\033[0;97m\]"
BLUE="\[\033[0;34m\]"
PS_CLEAR="\[\033[0m\]"
SCREEN_ESC="\[\033k\033\134\]"

if [ "$LOGNAME" = "root" ]; then
    COLOR1="${RED}"
    COLOR2="${BROWN}"
    P="#"
else
    COLOR1="${BLUE}"
    COLOR2="${BROWN}"
    P="\$"
fi

prompt_dumb() {
    PS1="[\w] \$ "
}

prompt_simple() {
    unset PROMPT_COMMAND
    PS1="[\u@\h:\w]\$ "
    PS2="> "
}

prompt_compact() {
    unset PROMPT_COMMAND
    PS1="${GREY}[${COLOR1}\u${GREY}@${COLOR2}\h${GREY}:${COLOR1}\w${GREY}]${COLOR2}$P${PS_CLEAR} "
    PS2="${BROWN}continue ${BROWN}> "
}

HAVE_GIT=$(command -v git)
if [ $HAVE_GIT ]; then
    prompt_color() {
        PS1="${GREY}[${COLOR1}\u${GREY}@${COLOR2}\h${GREY}:${COLOR1}\w${GREY}]${COLOR2}
\`if [ \$? == 0 ]; then echo \[\e[97m\]Î»\[\e[0m\]; else echo \[\e[31m\]Î»\[\e[0m\]; fi\` \`_git_headname\` ${COLOR1}$P${COLOR1} ${GREY}>${PS_CLEAR} "
        PS2="${BROWN}continue ${BROWN}> "
    }
else
    prompt_color() {
        PS1="${GREY}[${COLOR1}\u${GREY}@${COLOR2}\h${GREY}:${COLOR1}\W${GREY}]${COLOR2}$P${PS_CLEAR} "
        PS2="${BROWN}continue ${BROWN}> "
    }
fi

# Use the color prompt by default when interactive
if [ "$TERM" = "dumb" ]; then
    prompt_dumb
elif [ "$EMACS_SHELL" = "emacs" ]; then
    test -n "$PS1" && prompt_dumb
elif [ $HAVE_GIT ]; then
    test -n "$PS1" && prompt_color
else
    test -n "$PS1" && prompt_compact
fi

# ----------------------------------------------------------------------
# - Lightning:
test -f /home/jpablobr/.lightning/functions.sh &&
source /home/jpablobr/.lightning/functions.sh