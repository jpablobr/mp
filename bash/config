#!/bin/bash
# Much taken from:
# https://github.com/rtomayko/dotfiles
# awesomeness! Many thanks!
# TODO: complete -o default -o nospace -F _git_branch gb

# the basics
: ${HOME=~}
: ${LOGNAME=$(id -un)}
: ${UNAME=$(uname)}

# complete hostnames from this file
: ${HOSTFILE=$HOME/.ssh/known_hosts}
: ${HOSTNAME=$(/bin/hostname)}
# readline config
: ${INPUTRC=~/.inputrc}

# ----------------------------------------------------------------------
# SHELL OPTIONS:
# Emacs mode
set -o emacs

# bring in system bashrc
test -r /etc/bashrc &&
. /etc/bashrc

# notify of bg job completion immediately
set -o notify

# shell opts. see bash(1) for details
shopt -s cdspell >/dev/null 2>&1
shopt -s extglob >/dev/null 2>&1
shopt -s histappend >/dev/null 2>&1
shopt -s hostcomplete >/dev/null 2>&1
shopt -s interactive_comments >/dev/null 2>&1
shopt -u mailwarn >/dev/null 2>&1
shopt -s no_empty_cmd_completion >/dev/null 2>&1

# fuck that you have new mail shit
unset MAILCHECK

# disable core dumps
ulimit -S -c 0

# default umask
umask 0022

# ----------------------------------------------------------------------
# PATH:
#bin
PATH="/bin:/usr/bin:/usr/local/bin:$PATH"

#sbin
PATH="/usr/local/sbin:/usr/sbin:/sbin:$PATH"

# if ~/bin.
test -d "$HOME/bin" &&
PATH="$HOME/bin:$PATH"

# if node.js.
test -d "$HOME/local/node/bin" &&
PATH="$HOME/local/node/bin:$PATH"

# if RVM.
test -s  "$HOME/.rvm/scripts/rvm" &&
source "$HOME/.rvm/scripts/rvm"

# if bashmarks
test -f "$HOME/bin/bashmarks.sh" &&
source "$HOME/bin/bashmarks.sh"

# if SSH
test -f "$HOME/.ssh/environment" &&
SSH_ENV="$HOME/.ssh/environment"

# ----------------------------------------------------------------------
# ENVIRONMENT CONFIGURATION:
# detect interactive shell
case "$-" in
    *i*) INTERACTIVE=yes ;;
    *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
    -*) LOGIN=yes ;;
    *)  unset LOGIN ;;
esac

# enable en_US locale w/ utf-8 encodings if not already configured
: ${LANG:="en_US.UTF-8"}
: ${LANGUAGE:="en"}
: ${LC_CTYPE:="en_US.UTF-8"}
: ${LC_ALL:="en_US.UTF-8"}
export LANG LANGUAGE LC_CTYPE LC_ALL

# always use PASSIVE mode ftp
: ${FTP_PASSIVE:=1}
export FTP_PASSIVE

# ignore backups, CVS directories, python bytecode, vim swap files
FIGNORE="~:CVS:#:.pyc:.swp:.swa:apache-solr-*"

# history stuff
HISTCONTROL=ignoreboth
HISTFILESIZE=10000
HISTSIZE=1000
BIBINPUTS=.:/usr/share/texmf-texlive/bibtex
TEXINPUTS=.:/usr/share/texmf-texlive/tex/

# ----------------------------------------------------------------------
# PAGER / EDITOR:
# See what we have to work with.
HAVE_EMACS=$(command -v emacs)

# EDITOR
test -n "$HAVE_EMACS" &&
VISUAL='emacs -nw' &&
EDITOR='emacs -nw'

# PAGER
if test -n "$(command -v less)" ; then
    PAGER="less -FirSwX"
    MANPAGER="less -FiRswX"
else
    PAGER=more
    MANPAGER="$PAGER"
fi

# Ack
ACK_PAGER="$PAGER"
ACK_PAGER_COLOR="$PAGER"

# ----------------------------------------------------------------------
# PROMP:
GREEN="\[\033[0;32m\]"
RED="\[\033[0;31m\]"
BROWN="\[\033[0;33m\]"
GREY="\[\033[0;97m\]"
BLUE="\[\033[0;34m\]"
PS_CLEAR="\[\033[0m\]"
SCREEN_ESC="\[\033k\033\134\]"

ANSI_RESET="\001$(git config --get-color "" "reset")\002"

# detect whether the tree is in a dirty state. returns
_git_dirty() {
	if git status 2>/dev/null | fgrep -q '(working directory clean)'; then
		return 0
	fi
	local dirty_marker="`git config gitsh.dirty || echo ' *'`"
	_git_apply_color "$dirty_marker" "color.sh.dirty" "red"
}

# detect the current branch; use 7-sha when not on branch
_git_headname() {
	local br=`git symbolic-ref -q HEAD 2>/dev/null`
	[ -n "$br" ] &&
		br=${br#refs/heads/} ||
		br=`git rev-parse --short HEAD 2>/dev/null`
	_git_apply_color "$br" "color.sh.branch" " yellow reverse"
}

# detect working directory relative to working tree root
_git_workdir() {
	subdir=`git rev-parse --show-prefix 2>/dev/null`
	subdir="${subdir%/}"
	workdir="${PWD%/$subdir}"
	_git_apply_color "${workdir/*\/}${subdir:+/$subdir}" "color.sh.workdir" "blue bold"
}

# determine whether color should be enabled. this checks git's color.ui
# option and then color.sh.
_git_color_enabled() {
	[ `git config --get-colorbool color.sh true` = "true" ]
}

# apply a color to the first argument
_git_apply_color() {
	local output="$1" color="$2" default="$3"
	if _git_color_enabled ; then
		color=`_git_color "$color" "$default"`
		echo -ne "${color}${output}${ANSI_RESET}"
	else
		echo -ne "$output"
	fi
}

# retrieve an ANSI color escape sequence from git config
_git_color() {
	local color
	color=`git config --get-color "$1" "$2" 2>/dev/null`
	[ -n "$color" ] && echo -ne "\001$color\002"
}

if [ "$LOGNAME" = "root" ]; then
    COLOR1="${RED}"
    COLOR2="${BROWN}"
    P="#"
else
    COLOR1="${BLUE}"
    COLOR2="${BROWN}"
    P="\$"
fi

prompt_dumb() {
    PS1='$ '
}

prompt_simple() {
    unset PROMPT_COMMAND
    PS1="[\u@\h:\w]\$ "
    PS2="> "
}

prompt_compact() {
    unset PROMPT_COMMAND
    PS1="${COLOR1}${P}${PS_CLEAR} "
    PS2="> "
}

prompt_color() {
    PS1="\`_git_workdir\`:${COLOR2}\h${COLOR1}\`_git_dirty\`
${COLOR1}!\`_git_headname\`${COLOR1}$P${COLOR1}${PS_CLEAR} "
    PS2="\[[33;1m\]continue \[[0m[1m\]> "
}

# ----------------------------------------------------------------------
# BASH COMPLETION:
test -z "$BASH_COMPLETION" && {
    bash=${BASH_VERSION%.*}; bmajor=${bash%.*}; bminor=${bash#*.}
    test -n "$PS1" && test $bmajor -gt 1 && {
        # search for a bash_completion file to source
        for f in /usr/local/etc/bash_completion \
            /usr/pkg/etc/bash_completion \
            /opt/local/etc/bash_completion \
            /etc/bash_completion
        do
            test -f $f && {
                . $f
                break
            }
        done
    }
    unset bash bmajor bminor
}

# override and disable tilde expansion
_expand() {
    return 0
}

# ----------------------------------------------------------------------
# LS AND DIRCOLORS:
# if the dircolors utility is available, set that up to
# dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$dircolors" && {
    COLORS=/etc/DIR_COLORS
    test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
    test -e "$HOME/.dircolors"        && COLORS="$HOME/.dircolors"
    test ! -e "$COLORS"               && COLORS=
    eval `dircolors --sh $COLORS`
}

unset dircolors
export LS_OPTIONS='-s -F -T 0 --color=yes'

# --------------------------------------------------------------------
# PATH MANIPULATION FUNCTIONS:
# Usage: pls [<var>]
# List path entries of PATH or environment variable <var>.
pls () { eval echo \$${1:-PATH} |tr : '\n'; }

# Usage: pshift [-n <num>] [<var>]
# Shift <num> entries off the front of PATH or environment var <var>.
# with the <var> option. Useful: pshift $(pwd)
pshift () {
    local n=1
    [ "$1" = "-n" ] && { n=$(( $2 + 1 )); shift 2; }
    eval "${1:-PATH}='$(pls |tail -n +$n |tr '\n' :)'"
}

# Usage: ppop [-n <num>] [<var>]
# Pop <num> entries off the end of PATH or environment variable <var>.
ppop () {
    local n=1 i=0
    [ "$1" = "-n" ] && { n=$2; shift 2; }
    while [ $i -lt $n ]
    do eval "${1:-PATH}='\${${1:-PATH}%:*}'"
        i=$(( i + 1 ))
    done
}

# Usage: prm <path> [<var>]
# Remove <path> from PATH or environment variable <var>.
prm () { eval "${2:-PATH}='$(pls $2 |grep -v "^$1\$" |tr '\n' :)'"; }

# Usage: punshift <path> [<var>]
# Shift <path> onto the beginning of PATH or environment variable <var>.
punshift () { eval "${2:-PATH}='$1:$(eval echo \$${2:-PATH})'"; }

# Usage: ppush <path> [<var>]
ppush () { eval "${2:-PATH}='$(eval echo \$${2:-PATH})':$1"; }

# Usage: puniq [<path>]
# Remove duplicate entries from a PATH style value while retaining
# the original order. Use PATH if no <path> is given.
#
# Example:
#   $ puniq /usr/bin:/usr/local/bin:/usr/bin
#   /usr/bin:/usr/local/bin
puniq () {
    echo "$1" |tr : '\n' |nl |sort -u -k 2,2 |sort -n |
    cut -f 2- |tr '\n' : |sed -e 's/:$//' -e 's/^://'
}

# use gem-man(1) if available:
man () {
    gem man -s "$@" 2>/dev/null ||
    command man "$@"
}

# -------------------------------------------------------------------
# USER SHELL ENVIRONMENT:
# bring in rbdev functions
. rbdev 2>/dev/null || true

# source ~/.shenv now if it exists
test -r ~/.shenv &&
. ~/.shenv

# condense PATH entries
PATH=$(puniq $PATH)
MANPATH=$(puniq $MANPATH)

# Use the color prompt by default when interactive
HAVE_GIT=$(command -v git)
if [ "$TERM" = "dumb" ]; then
    prompt_dumb
elif [ $HAVE_GIT ]; then
    test -n "$PS1" && prompt_color
else
    test -n "$PS1" && prompt_compact
fi

# -------------------------------------------------------------------
# MOTD / FORTUNE:
test -n "$INTERACTIVE" -a -n "$LOGIN" && {
    uname -npsr
    uptime
}

# -------------------------------------------------------------------
# SSH agent settings
function start_agent {
    echo "Initialising new SSH agent..."
    /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
    echo succeeded
    chmod 600 "${SSH_ENV}"
    . "${SSH_ENV}" > /dev/null
    /usr/bin/ssh-add;
}

if [ -f "${SSH_ENV}" ]; then
    . "${SSH_ENV}" > /dev/null
    ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
        start_agent;
    }
else
    start_agent;
fi

# push SSH public key to another box
push_ssh_cert() {
    local _host
    test -f ~/.ssh/id_dsa.pub || ssh-keygen -t dsa
    for _host in "$@";
    do
        echo $_host
        ssh $_host 'cat >> ~/.ssh/authorized_keys' < ~/.ssh/id_dsa.pub
    done
}