--- 
vimtips: "\" searching\r\n\
  /joe/e                      : cursor set to End of match\r\n\
  3/joe/e+1                   : find 3rd joe cursor set to End of match plus 1 \r\n\
  /joe/s-2                    : cursor set to Start of match minus 2\r\n\
  /joe/+3                     : find joe move cursor 3 lines down\r\n\
  /^joe.*fred.*bill/          : find joe AND fred AND Bill (Joe at start of line)\r\n\
  /^[A-J]/                    : search for lines beginning with one or more A-J\r\n\
  /begin\\_.*end               : search over possible multiple lines\r\n\
  /fred\\_s*joe/               : any whitespace including newline \r\n\
  /fred\\|joe                  : Search for FRED OR JOE\r\n\
  /.*fred\\&.*joe              : Search for FRED AND JOE in any ORDER!\r\n\
  /\\<fred\\>/                  : search for fred but not alfred or frederick \r\n\
  /\\<\\d\\d\\d\\d\\>               : Search for exactly 4 digit numbers\r\n\
  /\\D\\d\\d\\d\\d\\D               : Search for exactly 4 digit numbers\r\n\
  /\\<\\d\\{4}\\>                 : same thing\r\n\
  /\\([^0-9]\\|^\\)%.*%          : Search for absence of a digit or beginning of line\r\n\
  \r\n\
  \" finding empty lines\r\n\
  /^\\n\\{3}                    : find 3 empty lines\r\n\
  /^str.*\\nstr                : find 2 successive lines starting with str\r\n\
  /\\(^str.*\\n\\)\\{2}           : find 2 successive lines starting with str\r\n\
  \r\n\
  \" using rexexp memory in a search\r\n\
  /\\(fred\\).*\\(joe\\).*\\2.*\\1\r\n\
  \r\n\
  \" Repeating the Regexp (rather than what the Regexp finds)\r\n\
  /^\\([^,]*,\\)\\{8}\r\n\
  \r\n\
  \" visual searching\r\n\
  :vmap // y/<C-R>\"<CR>       : search for visually highlighted text\r\n\
  :vmap <silent> //    y/<C-R>=escape(@\", '\\\\/.*$^~[]')<CR><CR> : with spec chars\r\n\
  \r\n\
  \" \\zs and \\ze regex delimiters :h /\\zs\r\n\
  /<\\zs[^>]*\\ze>              : search for tag contents, ignoring chevrons\r\n\
  \r\n\
  \" zero-width :h /\\@=\r\n\
  /<\\@<=[^>]*>\\@=             : search for tag contents, ignoring chevrons\r\n\
  /<\\@<=\\_[^>]*>\\@=           : search for tags across possible multiple lines\r\n\
  \r\n\
  \" searching over multiple lines \\_ means including newline\r\n\
  /<!--\\_p\\{-}-->                   : search for multiple line comments\r\n\
  /fred\\_s*joe/                     : any whitespace including newline \r\n\
  /bugs\\(\\_.\\)*bunny                : bugs followed by bunny anywhere in file\r\n\
  :h \\_                             : help\r\n\
  \r\n\
  \" search for declaration of subroutine/function under cursor\r\n\
  :nmap gx yiw/^\\(sub\\<bar>function\\)\\s\\+<C-R>\"<CR>\r\n\
  \r\n\
  \" multiple file search\r\n\
  :bufdo /searchstr/                : use :rewind to recommence search\r\n\
  \r\n\
  \" multiple file search better but cheating\r\n\
  :bufdo %s/searchstr/&/gic   : say n and then a to stop\r\n\
  \r\n\
  \" How to search for a URL without backslashing\r\n\
  ?http://www.vim.org/        : (first) search BACKWARDS!!! clever huh!\r\n\
  \r\n\
  \" Specify what you are NOT searching for (vowels)\r\n\
  /\\c\\v([^aeiou]&\\a){4}       : search for 4 consecutive consonants\r\n\
  /\\%>20l\\%<30lgoat           : Search for goat between lines 20 and 30 \r\n\
  /^.\\{-}home.\\{-}\\zshome/e   : match only the 2nd occurence in a line of \"home\" \r\n\
  :%s/home.\\{-}\\zshome/alone  : Substitute only the occurrence of home in any line \r\n\
  \r\n\
  \" find str but not on lines containing tongue\r\n\
  ^\\(.*tongue.*\\)\\@!.*nose.*$\r\n\
  \\v^((tongue)@!.)*nose((tongue)@!.)*$\r\n\
  .*nose.*\\&^\\%(\\%(tongue\\)\\@!.\\)*$ \r\n\
  :v/tongue/s/nose/&/gic\r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \"substitution\r\n\
  :%s/fred/joe/igc            : general substitute command\r\n\
  :%s//joe/igc                : Substitute what you last searched for \r\n\
  :%s/~/sue/igc               : Substitute your last replacement string \r\n\
  :%s/\\r//g                   : Delete DOS returns ^M\r\n\
  \r\n\
  \" Is your Text File jumbled onto one line? use following\r\n\
  :%s/\\r/\\r/g                 : Turn DOS returns ^M into real returns\r\n\
  :%s=  *$==                  : delete end of line blanks\r\n\
  :%s= \\+$==                  : Same thing\r\n\
  :%s#\\s*\\r\\?$##              : Clean both trailing spaces AND DOS returns\r\n\
  :%s#\\s*\\r*$##               : same thing\r\n\
  \r\n\
  \" deleting empty lines\r\n\
  :%s/^\\n\\{3}//               : delete blocks of 3 empty lines\r\n\
  :%s/^\\n\\+/\\r/               : compressing empty lines\r\n\
  :%s#<[^>]\\+>##g             : delete html tags, leave text (non-greedy)\r\n\
  :%s#<\\_.\\{-1,}>##g          : delete html tags possibly multi-line (non-greedy)\r\n\
  :%s#.*\\(\\d\\+hours\\).*#\\1#   : Delete all but memorised string (\\1) \r\n\
  %s#><\\([^/]\\)#>\\r<\\1#g      : split jumbled up XML file into one tag per line \r\n\
  \r\n\
  \" VIM Power Substitute\r\n\
  :'a,'bg/fred/s/dick/joe/igc : VERY USEFUL\r\n\
  \r\n\
  \" duplicating columns\r\n\
  :%s= [^ ]\\+$=&&=            : duplicate end column\r\n\
  :%s= \\f\\+$=&&=              : same thing\r\n\
  :%s= \\S\\+$=&&               : usually the same\r\n\
  \r\n\
  \" memory\r\n\
  %s#.*\\(tbl_\\w\\+\\).*#\\1#     : produce a list of all strings tbl_*   \r\n\
  :s/\\(.*\\):\\(.*\\)/\\2 : \\1/   : reverse fields separated by :\r\n\
  :%s/^\\(.*\\)\\n\\1$/\\1/        : delete duplicate lines\r\n\
  \r\n\
  \" non-greedy matching \\{-}\r\n\
  :%s/^.\\{-}pdf/new.pdf/      : delete to 1st occurence of pdf only (non-greedy)\r\n\
  \r\n\
  \" use of optional atom \\?\r\n\
  :%s#\\<[zy]\\?tbl_[a-z_]\\+\\>#\\L&#gc : lowercase with optional leading characters\r\n\
  \r\n\
  \" over possibly many lines\r\n\
  :%s/<!--\\_.\\{-}-->//        : delete possibly multi-line comments\r\n\
  :help /\\{-}                 : help non-greedy\r\n\
  \r\n\
  \" substitute using a register\r\n\
  :s/fred/<c-r>a/g            : sub \"fred\" with contents of register \"a\"\r\n\
  :s/fred/<c-r>asome_text<c-r>s/g  \r\n\
  :s/fred/\\=@a/g              : better alternative as register not displayed\r\n\
  \r\n\
  \" multiple commands on one line\r\n\
  :%s/\\f\\+\\.gif\\>/\\r&\\r/g | v/\\.gif$/d | %s/gif/jpg/\r\n\
  :%s/a/but/gie|:update|:next : then use @: to repeat\r\n\
  \r\n\
  \" ORing\r\n\
  :%s/goat\\|cow/sheep/gc      : ORing (must break pipe)\r\n\
  :'a,'bs#\\[\\|\\]##g           : remove [] from lines between markers a and b \r\n\
  :%s/\\v(.*\\n){5}/&\\r         : insert a blank line every 5 lines \r\n\
  \r\n\
  \" Calling a VIM function\r\n\
  :s/__date__/\\=strftime(\"%c\")/ : insert datestring\r\n\
  \r\n\
  \" Working with Columns sub any str1 in col3\r\n\
  :%s:\\(\\(\\w\\+\\s\\+\\)\\{2}\\)str1:\\1str2:\r\n\
  \r\n\
  \" Swapping first & last column (4 columns)\r\n\
  :%s:\\(\\w\\+\\)\\(.*\\s\\+\\)\\(\\w\\+\\)$:\\3\\2\\1:\r\n\
  \r\n\
  \" format a mysql query \r\n\
  :%s#\\<from\\>\\|\\<where\\>\\|\\<left join\\>\\|\\<\\inner join\\>#\\r&#g\r\n\
  \r\n\
  \" filter all form elements into paste register\r\n\
  :redir @*|sil exec 'g#<\\(input\\|select\\|textarea\\|/\\=form\\)\\>#p'|redir END\r\n\
  :nmap ,z :redir @*<Bar>sil exec 'g@<\\(input\\<Bar>select\\<Bar>textarea\\<Bar>/\\=form\\)\\>@p'<Bar>redir END<CR>\r\n\
  \r\n\
  \" substitute string in column 30 \r\n\
  :%s/^\\(.\\{30\\}\\)xx/\\1yy/\r\n\
  \r\n\
  \" decrement numbers by 3\r\n\
  :%s/\\d\\+/\\=(submatch(0)-3)/\r\n\
  \r\n\
  \" increment numbers by 6 on certain lines only\r\n\
  :g/loc\\|function/s/\\d/\\=submatch(0)+6/\r\n\
  \r\n\
  \" better\r\n\
  :%s#txtdev\\zs\\d#\\=submatch(0)+1#g\r\n\
  :h /\\zs\r\n\
  \r\n\
  \" increment only numbers gg\\d\\d  by 6 (another way)\r\n\
  :%s/\\(gg\\)\\@<=\\d\\+/\\=submatch(0)+6/\r\n\
  :h zero-width\r\n\
  \r\n\
  \" rename a string with an incrementing number\r\n\
  :let i=10 | 'a,'bg/Abc/s/yy/\\=i/ |let i=i+1 # convert yy to 10,11,12 etc\r\n\
  \r\n\
  \" as above but more precise\r\n\
  :let i=10 | 'a,'bg/Abc/s/xx\\zsyy\\ze/\\=i/ |let i=i+1 # convert xxyy to xx11,xx12,xx13\r\n\
  \r\n\
  \" find replacement text, put in memory, then use \\zs to simplify substitute\r\n\
  :%s/\"\\([^.]\\+\\).*\\zsxx/\\1/\r\n\
  \r\n\
  \" Pull word under cursor into LHS of a substitute\r\n\
  :nmap <leader>z :%s#\\<<c-r>=expand(\"<cword>\")<cr>\\>#\r\n\
  \r\n\
  \" Pull Visually Highlighted text into LHS of a substitute\r\n\
  :vmap <leader>z :<C-U>%s/\\<<c-r>*\\>/\r\n\
  \r\n\
  \" substitute singular or plural\r\n\
  :'a,'bs/bucket\\(s\\)*/bowl\\1/gic   \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" all following performing similar task, substitute within substitution\r\n\
  \r\n\
  \" Multiple single character substitution in a portion of line only\r\n\
  :%s,\\(all/.*\\)\\@<=/,_,g     : replace all / with _ AFTER \"all/\"\r\n\
  \r\n\
  \" Same thing\r\n\
  :s#all/\\zs.*#\\=substitute(submatch(0), '/', '_', 'g')#\r\n\
  \r\n\
  \" Substitute by splitting line, then re-joining\r\n\
  :s#all/#&^M#|s#/#_#g|-j!\r\n\
  \r\n\
  \" Substitute inside substitute\r\n\
  :%s/.*/\\='cp '.submatch(0).' all/'.substitute(submatch(0),'/','_','g')/\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" global command display \r\n\
  :g/gladiolli/#              : display with line numbers (YOU WANT THIS!)\r\n\
  :g/fred.*joe.*dick/         : display all lines fred,joe & dick\r\n\
  :g/\\<fred\\>/                : display all lines fred but not freddy\r\n\
  :g/^\\s*$/d                  : delete all blank lines\r\n\
  :g!/^dd/d                   : delete lines not containing string\r\n\
  :v/^dd/d                    : delete lines not containing string\r\n\
  :g/joe/,/fred/d             : not line based (very powerfull)\r\n\
  :g/fred/,/joe/j             : Join Lines \r\n\
  :g/-------/.-10,.d          : Delete string & 10 previous lines\r\n\
  :g/{/ ,/}/- s/\\n\\+/\\r/g     : Delete empty lines but only between {...}\r\n\
  :v/\\S/d                     : Delete empty lines (and blank lines ie whitespace)\r\n\
  :v/./,/./-j                 : compress empty lines\r\n\
  :g/^$/,/./-j                : compress empty lines\r\n\
  :g/<input\\|<form/p          : ORing\r\n\
  :g/^/put_                   : double space file (pu = put)\r\n\
  :g/^/m0                     : Reverse file (m = move)\r\n\
  :g/^/m$                     : No effect! \r\n\
  :'a,'bg/^/m'b               : Reverse a section a to b\r\n\
  :g/^/t.                     : duplicate every line\r\n\
  :g/fred/t$                  : copy(transfer) lines matching fred to EOF\r\n\
  :g/stage/t'a                : copy (transfer) lines matching stage to marker a (cannot use .) \r\n\
  :g/^Chapter/t.|s/./-/g      : Automatically underline selecting headings \r\n\
  :g/\\(^I[^^I]*\\)\\{80}/d      : delete all lines containing at least 80 tabs\r\n\
  \r\n\
  \" perform a substitute on every other line\r\n\
  :g/^/ if line('.')%2|s/^/zz / \r\n\
  \r\n\
  \" match all lines containing \"somestr\" between markers a & b\r\n\
  \r\n\
  \" copy after line containing \"otherstr\"\r\n\
  :'a,'bg/somestr/co/otherstr/ : co(py) or mo(ve)\r\n\
  \r\n\
  \" as above but also do a substitution\r\n\
  :'a,'bg/str1/s/str1/&&&/|mo/str2/\r\n\
  :%norm jdd                  : delete every other line\r\n\
  \r\n\
  \" incrementing numbers (type <c-a> as 5 characters)\r\n\
  :.,$g/^\\d/exe \"norm! \\<c-a>\": increment numbers\r\n\
  :'a,'bg/\\d\\+/norm! ^A       : increment numbers\r\n\
  \r\n\
  \" storing glob results (note must use APPEND) you need to empty reg a first with qaq. \r\n\
  \r\n\
  \"save results to a register/paste buffer\r\n\
  :g/fred/y A                 : append all lines fred to register a\r\n\
  :g/fred/y A | :let @*=@a    : put into paste buffer\r\n\
  :let @a=''|g/Barratt/y A |:let @*=@a\r\n\
  \r\n\
  \" filter lines to a file (file must already exist)\r\n\
  :'a,'bg/^Error/ . w >> errors.txt\r\n\
  \r\n\
  \" duplicate every line in a file wrap a print '' around each duplicate\r\n\
  :g/./yank|put|-1s/'/\"/g|s/.*/Print '&'/\r\n\
  \r\n\
  \" replace string with contents of a file, -d deletes the \"mark\"\r\n\
  :g/^MARK$/r tmp.txt | -d\r\n\
  \r\n\
  \" display prettily\r\n\
  :g/<pattern>/z#.5           : display with context\r\n\
  :g/<pattern>/z#.5|echo \"==========\"  : display beautifully\r\n\
  \r\n\
  \" Combining g// with normal mode commands\r\n\
  :g/|/norm 2f|r*                      : replace 2nd | with a star\r\n\
  \r\n\
  \"send output of previous global command to a new window\r\n\
  :nmap <F3>  :redir @a<CR>:g//<CR>:redir END<CR>:new<CR>:put! a<CR><CR>\r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \" Global combined with substitute (power editing)\r\n\
  :'a,'bg/fred/s/joe/susan/gic :  can use memory to extend matching\r\n\
  :/fred/,/joe/s/fred/joe/gic :  non-line based (ultra)\r\n\
  :/biz/,/any/g/article/s/wheel/bucket/gic:  non-line based \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Find fred before beginning search for joe\r\n\
  :/fred/;/joe/-2,/sid/+3s/sally/alley/gIC\r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \" create a new file for each line of file eg 1.txt,2.txt,3,txt etc\r\n\
  :g/^/exe \".w \".line(\".\").\".txt\"\r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \" chain an external command\r\n\
  :.g/^/ exe \".!sed 's/N/X/'\" | s/I/Q/    \r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \" Operate until string found \r\n\
  d/fred/                                :delete until fred\r\n\
  y/fred/                                :yank until fred\r\n\
  c/fred/e                               :change until fred end\r\n\
  \r\n\
  \"----------------------------------------\r\n\
  \r\n\
  \" Summary of editing repeats \r\n\
  .      last edit (magic dot)\r\n\
  :&     last substitute\r\n\
  :%&    last substitute every line\r\n\
  :%&gic last substitute every line confirm\r\n\
  g%     normal mode repeat last substitute\r\n\
  g&     last substitute on all lines\r\n\
  @@     last recording\r\n\
  @:     last command-mode command\r\n\
  :!!    last :! command\r\n\
  :~     last substitute\r\n\
  :help repeating\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Summary of repeated searches\r\n\
  ;      last f, t, F or T\r\n\
  ,      last f, t, F or T in opposite direction\r\n\
  n      last / or ? search\r\n\
  N      last / or ? search in opposite direction\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Absolutely essential\r\n\
  ----------------------------------------\r\n\
  * # g* g#           : find word under cursor (<cword>) (forwards/backwards)\r\n\
  %                   : match brackets {}[]()\r\n\
  .                   : repeat last modification \r\n\
  @:                  : repeat last : command (then @@)\r\n\
  matchit.vim         : % now matches tags <tr><td><script> <?php etc\r\n\
  <C-N><C-P>          : word completion in insert mode\r\n\
  <C-X><C-L>          : Line complete SUPER USEFUL\r\n\
  /<C-R><C-W>         : Pull <cword> onto search/command line\r\n\
  /<C-R><C-A>         : Pull <CWORD> onto search/command line\r\n\
  :set ignorecase     : you nearly always want this\r\n\
  :set smartcase      : overrides ignorecase if uppercase used in search string (cool)\r\n\
  :syntax on          : colour syntax in Perl,HTML,PHP etc\r\n\
  :set syntax=perl    : force syntax (usually taken from file extension)\r\n\
  :h regexp<C-D>      : type control-D and get a list all help topics containing\r\n                      regexp (plus use TAB to Step thru list)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" MAKE IT EASY TO UPDATE/RELOAD _vimrc\r\n\
  :nmap ,s :source $VIM/_vimrc\r\n\
  :nmap ,v :e $VIM/_vimrc\r\n\
  :e $MYVIMRC         : edits your _vimrc whereever it might be  \r\n\
  \r\n\
  \" How to have a variant in your .vimrc for different PCs \r\n\
  if $COMPUTERNAME == \"NEWPC\"\r\n\
  ab mypc vista\r\n\
  else\r\n\
  ab mypc dell25\r\n\
  endif\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" splitting windows\r\n\
  :vsplit other.php       # vertically split current file with other.php \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \"VISUAL MODE (easy to add other HTML Tags)\r\n\
  :vmap sb \"zdi<b><C-R>z</b><ESC>  : wrap <b></b> around VISUALLY selected Text\r\n\
  :vmap st \"zdi<?= <C-R>z ?><ESC>  : wrap <?=   ?> around VISUALLY selected Text\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \"vim 7 tabs\r\n\
  vim -p fred.php joe.php             : open files in tabs\r\n\
  :tabe fred.php                      : open fred.php in a new tab\r\n\
  :tab ball                           : tab open files\r\n\
  \r\n\
  \" vim 7 forcing use of tabs from .vimrc\r\n\
  :nnoremap gf <C-W>gf\r\n\
  :cab      e  tabe\r\n\
  :tab sball                           : retab all files in buffer (repair) \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Exploring\r\n\
  :e .                            : file explorer\r\n\
  :Exp(lore)                      : file explorer note capital Ex\r\n\
  :Sex(plore)                     : file explorer in split window\r\n\
  :browse e                       : windows style browser\r\n\
  :ls                             : list of buffers\r\n\
  :cd ..                          : move to parent directory\r\n\
  :args                           : list of files\r\n\
  :args *.php                     : open list of files (you need this!)\r\n\
  :lcd %:p:h                      : change to directory of current file\r\n\
  :autocmd BufEnter * lcd %:p:h   : change to directory of current file automatically (put in _vimrc)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Changing Case\r\n\
  guu                             : lowercase line\r\n\
  gUU                             : uppercase line\r\n\
  Vu                              : lowercase line\r\n\
  VU                              : uppercase line\r\n\
  g~~                             : flip case line\r\n\
  vEU                             : Upper Case Word\r\n\
  vE~                             : Flip Case Word\r\n\
  ggguG                           : lowercase entire file\r\n\
  \r\n\
  \" Titlise Visually Selected Text (map for .vimrc)\r\n\
  vmap ,c :s/\\<\\(.\\)\\(\\k*\\)\\>/\\u\\1\\L\\2/g<CR>\r\n\
  \r\n\
  \" titlise a line\r\n\
  nmap ,t :s/.*/\\L&/<bar>:s/\\<./\\u&/g<cr>  \r\n\
  \r\n\
  \" Uppercase first letter of sentences\r\n\
  :%s/[.!?]\\_s\\+\\a/\\U&\\E/g\r\n\
  ----------------------------------------\r\n\
  gf                              : open file name under cursor (SUPER)\r\n\
  :nnoremap gF :view <cfile><cr>  : open file under cursor, create if necessary\r\n\
  ga                              : display hex,ascii value of char under cursor\r\n\
  ggVGg?                          : rot13 whole file\r\n\
  ggg?G                           : rot13 whole file (quicker for large file)\r\n\
  :8 | normal VGg?                : rot13 from line 8\r\n\
  :normal 10GVGg?                 : rot13 from line 8\r\n\
  <C-A>,<C-X>                     : increment,decrement number under cursor\r\n                                  win32 users must remap CNTRL-A\r\n\
  <C-R>=5*5                       : insert 25 into text (mini-calculator)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Make all other tips superfluous\r\n\
  :h 42            : also http://www.google.com/search?q=42\r\n\
  :h holy-grail\r\n\
  :h!\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" disguise text (watch out) \r\n\
  ggVGg?                          : rot13 whole file (toggles)\r\n\
  :set rl!                        : reverse lines right to left (toggles)\r\n\
  :g/^/m0                         : reverse lines top to bottom (toggles)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Markers & moving about\r\n\
  '.               : jump to last modification line (SUPER)\r\n\
  `.               : jump to exact spot in last modification line\r\n\
  g;               : cycle thru recent changes (oldest first)\r\n\
  g,               : reverse direction \r\n\
  :changes\r\n\
  :h changelist    : help for above\r\n\
  <C-O>            : retrace your movements in file (starting from most recent)\r\n\
  <C-I>            : retrace your movements in file (reverse direction)\r\n\
  :ju(mps)         : list of your movements\r\n\
  :help jump-motions\r\n\
  :history         : list of all your commands\r\n\
  :his c           : commandline history\r\n\
  :his s           : search history\r\n\
  q/               : Search history Window (puts you in full edit mode) (exit CTRL-C)\r\n\
  q:               : commandline history Window (puts you in full edit mode) (exit CTRL-C)\r\n\
  :<C-F>           : history Window (exit CTRL-C)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Abbreviations & Maps\r\n\
  \r\n\
  \" Following 4 maps enable text transfer between VIM sessions\r\n\
  :map   <f7>   :'a,'bw! c:/aaa/x       : save text to file x\r\n\
  :map   <f8>   :r c:/aaa/x             : retrieve text \r\n\
  :map   <f11>  :.w! c:/aaa/xr<CR>      : store current line\r\n\
  :map   <f12>  :r c:/aaa/xr<CR>        : retrieve current line\r\n\
  :ab php          : list of abbreviations beginning php\r\n\
  :map ,           : list of maps beginning ,\r\n\
  \r\n\
  \" allow use of F10 for mapping (win32)\r\n\
  set wak=no       : :h winaltkeys\r\n\
  \r\n\
  \" For use in Maps\r\n\
  <CR>             : carriage Return for maps\r\n\
  <ESC>            : Escape\r\n\
  <LEADER>         : normally \\\r\n\
  <BAR>            : | pipe\r\n\
  <BACKSPACE>      : backspace\r\n\
  <SILENT>         : No hanging shell window\r\n\
  #display RGB colour under the cursor eg #445588\r\n\
  :nmap <leader>c :hi Normal guibg=#<c-r>=expand(\"<cword>\")<cr><cr>\r\n\
  map <f2> /price only\\\\|versus/ :in a map need to backslash the \\\r\n\
  # type table,,, to get <table></table>       ### Cool ###\r\n\
  imap ,,, <esc>bdwa<<esc>pa><cr></<esc>pa><esc>kA\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Simple PHP debugging display all variables yanked into register a\r\n\
  iab phpdb exit(\"<hr>Debug <C-R>a  \");\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Using a register as a map (preload registers in .vimrc)\r\n\
  :let @m=\":'a,'bs/\"\r\n\
  :let @s=\":%!sort -u\"\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Useful tricks\r\n\
  \r\n\
  \"ayy@a           : execute \"Vim command\" in a text file\r\n\
  yy@\"             : same thing using unnamed register\r\n\
  u@.              : execute command JUST typed in\r\n\
  \r\n\
  \"ddw             : store what you delete in register d \r\n\
  \r\n\
  \"ccaw            : store what you change in register c \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Get output from other commands (requires external programs)\r\n\
  :r!ls -R         : reads in output of ls\r\n\
  :put=glob('**')  : same as above                 \r\n\
  :r !grep \"^ebay\" file.txt  : grepping in content   \r\n\
  :20,25 !rot13    : rot13 lines 20 to 25   \r\n\
  !!date           : same thing (but replaces/filters current line)\r\n\
  \r\n\
  \" Sorting with external sort\r\n\
  :%!sort -u       : use an external program to filter content\r\n\
  :'a,'b!sort -u   : use an external program to filter content\r\n\
  !1} sort -u      : sorts paragraph (note normal mode!!)\r\n\
  :g/^$/;,/^$/-1!sort : Sort each block (note the crucial ;)\r\n\
  \r\n\
  \" Sorting with internal sort\r\n\
  :sort /.*\\%2v/   : sort all lines on second column \r\n\
  \r\n\
  \" number lines \r\n\
  :new | r!nl #                  \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Multiple Files Management (Essential)\r\n\
  :bn              : goto next buffer\r\n\
  :bp              : goto previous buffer\r\n\
  :wn              : save file and move to next (super)\r\n\
  :wp              : save file and move to previous\r\n\
  :bd              : remove file from buffer list (super)\r\n\
  :bun             : Buffer unload (remove window but not from list)\r\n\
  :badd file.c     : file from buffer list\r\n\
  :b3              : go to buffer 3 \r\n\
  :b main          : go to buffer with main in name eg main.c (ultra)\r\n\
  :sav php.html    : Save current file as php.html and \"move\" to php.html\r\n\
  :sav! %<.bak     : Save Current file to alternative extension (old way)\r\n\
  :sav! %:r.cfm    : Save Current file to alternative extension\r\n\
  :sav %:s/fred/joe/           : do a substitute on file name\r\n\
  :sav %:s/fred/joe/:r.bak2    : do a substitute on file name & ext.\r\n\
  :!mv % %:r.bak   : rename current file (DOS use Rename or DEL)\r\n\
  :help filename-modifiers\r\n\
  :e!              : return to unmodified file\r\n\
  :w c:/aaa/%      : save file elsewhere\r\n\
  :e #             : edit alternative file (also cntrl-^)\r\n\
  :rew             : return to beginning of edited files list (:args)\r\n\
  :brew            : buffer rewind\r\n\
  :sp fred.txt     : open fred.txt into a split\r\n\
  :sball,:sb       : Split all buffers (super)\r\n\
  :scrollbind      : in each split window\r\n\
  :map   <F5> :ls<CR>:e # : Pressing F5 lists all buffer, just type number\r\n\
  :set hidden      : Allows to change buffer w/o saving current buffer\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Quick jumping between splits\r\n\
  map <C-J> <C-W>j<C-W>_\r\n\
  map <C-K> <C-W>k<C-W>_\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Recording (BEST TIP of ALL)\r\n\
  qq  # record to q\r\n\
  your complex series of commands\r\n\
  q   # end recording\r\n\
  @q to execute\r\n\
  @@ to Repeat\r\n\
  5@@ to Repeat 5 times\r\n\
  qQ@qq                             : Make an existing recording q recursive \r\n\
  \r\n\
  \" editing a register/recording\r\n\
  \r\n\
  \"qp                               :display contents of register q (normal mode)\r\n\
  <ctrl-R>q                         :display contents of register q (insert mode)\r\n\
  \r\n\
  \" you can now see recording contents, edit as required\r\n\
  \r\n\
  \"qdd                              :put changed contacts back into q\r\n\
  @q                                :execute recording/register q\r\n\
  \r\n\
  \" Operating a Recording on a Visual BLOCK\r\n\
  1) define recording/register\r\n\
  qq:s/ to/ from/g^Mq\r\n\
  2) Define Visual BLOCK\r\n\
  V}\r\n\
  3) hit : and the following appears\r\n\
  :'<,'>\r\n\
  4)Complete as follows\r\n\
  :'<,'>norm @q\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \"combining a recording with a map (to end up in command mode)\r\n\
  :nnoremap ] @q:update<bar>bd\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Visual is the newest and usually the most intuitive editing mode\r\n\
  \r\n\
  \" Visual basics\r\n\
  v                               : enter visual mode\r\n\
  V                               : visual mode whole line\r\n\
  <C-V>                           : enter VISUAL BLOCK mode\r\n\
  gv                              : reselect last visual area (ultra)\r\n\
  o                               : navigate visual area\r\n\
  \r\n\
  \"*y or \"+y                      : yank visual area into paste buffer  \r\n\
  V%                              : visualise what you match\r\n\
  V}J                             : Join Visual block (great)\r\n\
  V}gJ                            : Join Visual block w/o adding spaces\r\n\
  `[v`]                           : Highlight last insert\r\n\
  :%s/\\%Vold/new/g                : Do a substitute on last visual area \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Delete first 2 characters of 10 successive lines\r\n\
  0<c-v>10j2ld  (use Control Q on win32) \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" how to copy a set of columns using VISUAL BLOCK\r\n\
  \r\n\
  \" visual block (AKA columnwise selection) (NOT BY ordinary v command)\r\n\
  <C-V> then select \"column(s)\" with motion commands (win32 <C-Q>)\r\n\
  then c,d,y,r etc\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" how to overwrite a visual-block of text with another such block \r\n\
  \r\n\
  \" move with hjkl etc\r\n\
  Pick the first block: ctrl-v move y\r\n\
  Pick the second block: ctrl-v move P <esc>\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" text objects :h text-objects                                     \r\n\
  daW                                   : delete contiguous non whitespace\r\n\
  di<   yi<  ci<                        : Delete/Yank/Change HTML tag contents\r\n\
  da<   ya<  ca<                        : Delete/Yank/Change whole HTML tag\r\n\
  dat   dit                             : Delete HTML tag pair\r\n\
  diB   daB                             : Empty a function {}\r\n\
  das                                   : delete a sentence\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" _vimrc essentials\r\n\
  :set incsearch : jumps to search word as you type (annoying but excellent)\r\n\
  :set wildignore=*.o,*.obj,*.bak,*.exe : tab complete now ignores these\r\n\
  :set shiftwidth=3                     : for shift/tabbing\r\n\
  :set vb t_vb=\".                       : set silent (no beep)\r\n\
  :set browsedir=buffer                 : Maki GUI File Open use current directory\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" launching Win IE\r\n\
  :nmap ,f :update<CR>:silent !start c:\\progra~1\\intern~1\\iexplore.exe file://%:p<CR>\r\n\
  :nmap ,i :update<CR>: !start c:\\progra~1\\intern~1\\iexplore.exe <cWORD><CR>\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" FTPing from VIM\r\n\
  cmap ,r  :Nread ftp://209.51.134.122/public_html/index.html\r\n\
  cmap ,w  :Nwrite ftp://209.51.134.122/public_html/index.html\r\n\
  gvim ftp://www.somedomain.com/index.html # uses netrw.vim\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" appending to registers (use CAPITAL)\r\n\
  \r\n\
  \" yank 5 lines into \"a\" then add a further 5\r\n\
  \r\n\
  \"a5yy\r\n\
  10j\r\n\
  \r\n\
  \"A5yy\r\n\
  ----------------------------------------\r\n\
  [I     : show lines matching word under cursor <cword> (super)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Conventional Shifting/Indenting\r\n\
  :'a,'b>>\r\n\
  \r\n\
  \" visual shifting (builtin-repeat)\r\n\
  :vnoremap < <gv\r\n\
  :vnoremap > >gv\r\n\
  \r\n\
  \" Block shifting (magic)\r\n\
  >i{\r\n\
  >a{\r\n\
  \r\n\
  \" also\r\n\
  >% and <%\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Redirection & Paste register *\r\n\
  :redir @*                    : redirect commands to paste buffer\r\n\
  :redir END                   : end redirect\r\n\
  :redir >> out.txt            : redirect to a file\r\n\
  \r\n\
  \" Working with Paste buffer\r\n\
  \r\n\
  \"*yy                         : yank curent line to paste\r\n\
  \r\n\
  \"*p                          : insert from paste buffer\r\n\
  \r\n\
  \" yank to paste buffer (ex mode)\r\n\
  :'a,'by*                     : Yank range into paste\r\n\
  :%y*                         : Yank whole buffer into paste\r\n\
  :.y*                         : Yank Current line to paster\r\n\
  \r\n\
  \" filter non-printable characters from the paste buffer\r\n\
  \r\n\
  \" useful when pasting from some gui application\r\n\
  :nmap <leader>p :let @* = substitute(@*,'[^[:print:]]','','g')<cr>\"*p\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Re-Formatting text\r\n\
  gq}                          : Format a paragraph\r\n\
  gqap                         : Format a paragraph\r\n\
  ggVGgq                       : Reformat entire file\r\n\
  Vgq                          : current line\r\n\
  \r\n\
  \" break lines at 70 chars, if possible after a ;\r\n\
  :s/.\\{,69\\};\\s*\\|.\\{,69\\}\\s\\+/&\\r/g\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Operate command over multiple files\r\n\
  :argdo %s/foo/bar/e          : operate on all files in :args\r\n\
  :bufdo %s/foo/bar/e\r\n\
  :windo %s/foo/bar/e\r\n\
  :argdo exe '%!sort'|w!       : include an external command\r\n\
  :bufdo exe \"normal @q\" | w   : perform a recording on open files\r\n\
  :silent bufdo !zip proj.zip %:p   : zip all current files\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Command line tricks\r\n\
  gvim -h                    : help\r\n\
  ls | gvim -                : edit a stream!!\r\n\
  cat xx | gvim - -c \"v/^\\d\\d\\|^[3-9]/d \" : filter a stream\r\n\
  gvim -o file1 file2        : open into a split\r\n\
  \r\n\
  \" execute one command after opening file\r\n\
  gvim.exe -c \"/main\" joe.c  : Open joe.c & jump to \"main\"\r\n\
  \r\n\
  \" execute multiple command on a single file\r\n\
  vim -c \"%s/ABC/DEF/ge | update\" file1.c\r\n\
  \r\n\
  \" execute multiple command on a group of files\r\n\
  vim -c \"argdo %s/ABC/DEF/ge | update\" *.c\r\n\
  \r\n\
  \" remove blocks of text from a series of files\r\n\
  vim -c \"argdo /begin/+1,/end/-1g/^/d | update\" *.c\r\n\
  \r\n\
  \" Automate editing of a file (Ex commands in convert.vim)\r\n\
  vim -s \"convert.vim\" file.c\r\n\
  #load VIM without .vimrc and plugins (clean VIM)\r\n\
  gvim -u NONE -U NONE -N\r\n\
  \r\n\
  \" Access paste buffer contents (put in a script/batch file)\r\n\
  gvim -c 'normal ggdG\"*p' c:/aaa/xp\r\n\
  \r\n\
  \" print paste contents to default printer\r\n\
  gvim -c 's/^/\\=@*/|hardcopy!|q!'\r\n\
  \r\n\
  \" gvim's use of external grep (win32 or *nix)\r\n\
  :!grep somestring *.php     : creates a list of all matching files \r\n\
  \r\n\
  \" use :cn(ext) :cp(rev) to navigate list\r\n\
  :h grep\r\n\
  \r\n\
  \" Using vimgrep with copen                              \r\n\
  :vimgrep /keywords/ *.php\r\n\
  :copen\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" GVIM Difference Function (Brilliant)\r\n\
  gvim -d file1 file2        : vimdiff (compare differences)\r\n\
  dp                         : \"put\" difference under cursor to other file\r\n\
  do                         : \"get\" difference under cursor from other file\r\n\
  \r\n\
  \" complex diff parts of same file \r\n\
  :1,2yank a | 7,8yank b\r\n\
  :tabedit | put a | vnew | put b\r\n\
  :windo diffthis \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Vim traps\r\n\
  In regular expressions you must backslash + (match 1 or more)\r\n\
  In regular expressions you must backslash | (or)\r\n\
  In regular expressions you must backslash ( (group)\r\n\
  In regular expressions you must backslash { (count)\r\n\
  /fred\\+/                   : matches fred/freddy but not free\r\n\
  /\\(fred\\)\\{2,3}/           : note what you have to break\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" \\v or very magic (usually) reduces backslashing\r\n\
  /codes\\(\\n\\|\\s\\)*where  : normal regexp\r\n\
  /\\vcodes(\\n|\\s)*where   : very magic\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" pulling objects onto command/search line (SUPER)\r\n\
  <C-R><C-W> : pull word under the cursor into a command line or search\r\n\
  <C-R><C-A> : pull WORD under the cursor into a command line or search\r\n\
  <C-R>-                  : pull small register (also insert mode)\r\n\
  <C-R>[0-9a-z]           : pull named registers (also insert mode)\r\n\
  <C-R>%                  : pull file name (also #) (also insert mode)\r\n\
  <C-R>=somevar           : pull contents of a variable (eg :let sray=\"ray[0-9]\")\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" List your Registers\r\n\
  :reg             : display contents of all registers\r\n\
  :reg a           : display content of register a\r\n\
  :reg 12a         : display content of registers 1,2 & a \r\n\
  \r\n\
  \"5p              : retrieve 5th \"ring\" \r\n\
  \r\n\
  \"1p....          : retrieve numeric registers one by one\r\n\
  :let @y='yy@\"'   : pre-loading registers (put in .vimrc)\r\n\
  qqq              : empty register \"q\"\r\n\
  qaq              : empty register \"a\"\r\n\
  :reg .-/%:*\"     : the seven special registers \r\n\
  :reg 0           : what you last yanked, not affected by a delete \r\n\
  \r\n\
  \"_dd             : Delete to blackhole register \"_ , don't affect any register \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" manipulating registers\r\n\
  :let @a=@_              : clear register a\r\n\
  :let @a=\"\"              : clear register a\r\n\
  :let @a=@\"              : Save unnamed register \r\n\
  :let @*=@a              : copy register a to paste buffer\r\n\
  :let @*=@:              : copy last command to paste buffer\r\n\
  :let @*=@/              : copy last search to paste buffer\r\n\
  :let @*=@%              : copy current filename to paste buffer\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" help for help (USE TAB)\r\n\
  :h quickref             : VIM Quick Reference Sheet (ultra)\r\n\
  :h tips                 : Vim's own Tips Help\r\n\
  :h visual<C-D><tab>     : obtain  list of all visual help topics\r\n                        : Then use tab to step thru them\r\n\
  :h ctrl<C-D>            : list help of all control keys\r\n\
  :helpg uganda           : grep HELP Files use :cn, :cp to find next\r\n\
  :helpgrep edit.*director: grep help using regexp\r\n\
  :h :r                   : help for :ex command\r\n\
  :h CTRL-R               : normal mode\r\n\
  :h /\\r                  : what's \\r in a regexp (matches a <CR>)\r\n\
  :h \\\\zs                 : double up backslash to find \\zs in help\r\n\
  :h i_CTRL-R             : help for say <C-R> in insert mode\r\n\
  :h c_CTRL-R             : help for say <C-R> in command mode\r\n\
  :h v_CTRL-V             : visual mode\r\n\
  :h tutor                : VIM Tutor\r\n\
  <C-[>, <C-T>            : Move back & Forth in HELP History\r\n\
  gvim -h                 : VIM Command Line Help\r\n\
  :cabbrev h tab h        : open help in a tab \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" where was an option set\r\n\
  :scriptnames            : list all plugins, _vimrcs loaded (super)\r\n\
  :verbose set history?   : reveals value of history and where set\r\n\
  :function               : list functions\r\n\
  :func SearchCompl       : List particular function\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" making your own VIM help\r\n\
  :helptags /vim/vim64/doc  : rebuild all *.txt help files in /doc\r\n\
  :help add-local-help\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" running file thru an external program (eg php)\r\n\
  map   <f9>   :w<CR>:!c:/php/php.exe %<CR>\r\n\
  map   <f2>   :w<CR>:!perl -c %<CR>\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" capturing output of current script in a separate buffer\r\n\
  :new | r!perl #                   : opens new buffer,read other buffer\r\n\
  :new! x.out | r!perl #            : same with named file\r\n\
  :new+read!ls\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" create a new buffer, paste a register \"q\" into it, then sort new buffer\r\n\
  :new +put q|%!sort\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Inserting DOS Carriage Returns\r\n\
  :%s/$/\\<C-V><C-M>&/g          :  that's what you type\r\n\
  :%s/$/\\<C-Q><C-M>&/g          :  for Win32\r\n\
  :%s/$/\\^M&/g                  :  what you'll see where ^M is ONE character\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" automatically delete trailing Dos-returns,whitespace\r\n\
  autocmd BufRead * silent! %s/[\\r \\t]\\+$//\r\n\
  autocmd BufEnter *.php :%s/[ \\t\\r]\\+$//e\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" perform an action on a particular file or file type\r\n\
  autocmd VimEnter c:/intranet/note011.txt normal! ggVGg?\r\n\
  autocmd FileType *.pl exec('set fileformats=unix')\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Retrieving last command line command for copy & pasting into text\r\n\
  i<c-r>:\r\n\
  \r\n\
  \" Retrieving last Search Command for copy & pasting into text\r\n\
  i<c-r>/\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" more completions\r\n\
  <C-X><C-F>                        :insert name of a file in current directory\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Substituting a Visual area\r\n\
  \r\n\
  \" select visual area as usual (:h visual) then type :s/Emacs/Vim/ etc\r\n\
  :'<,'>s/Emacs/Vim/g               : REMEMBER you dont type the '<.'>\r\n\
  gv                                : Re-select the previous visual area (ULTRA)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" inserting line number into file\r\n\
  :g/^/exec \"s/^/\".strpart(line(\".\").\"    \", 0, 4)\r\n\
  :%s/^/\\=strpart(line(\".\").\"     \", 0, 5)\r\n\
  :%s/^/\\=line('.'). ' '\r\n\
  ----------------------------------------\r\n\
  #numbering lines VIM way\r\n\
  :set number                       : show line numbers\r\n\
  :map <F12> :set number!<CR>       : Show linenumbers flip-flop\r\n\
  :%s/^/\\=strpart(line('.').\"        \",0,&ts)\r\n\
  #numbering lines (need Perl on PC) starting from arbitrary number\r\n\
  :'a,'b!perl -pne 'BEGIN{$a=223} substr($_,2,0)=$a++'\r\n\
  #Produce a list of numbers\r\n\
  #Type in number on line say 223 in an empty file\r\n\
  qqmnYP`n^Aq                       : in recording q repeat with @q\r\n\
  \r\n\
  \" increment existing numbers to end of file (type <c-a> as 5 characters)\r\n\
  :.,$g/^\\d/exe \"normal! \\<c-a>\"\r\n\
  \r\n\
  \" advanced incrementing\r\n\
  http://vim.sourceforge.net/tip_view.php?tip_id=150\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" advanced incrementing (really useful)\r\n\
  \r\n\
  \" put following in _vimrc\r\n\
  let g:I=0\r\n\
  function! INC(increment)\r\n\
  let g:I =g:I + a:increment\r\n\
  return g:I\r\n\
  endfunction\r\n\
  \r\n\
  \" eg create list starting from 223 incrementing by 5 between markers a,b\r\n\
  :let I=223\r\n\
  :'a,'bs/^/\\=INC(5)/\r\n\
  \r\n\
  \" create a map for INC\r\n\
  cab viminc :let I=223 \\| 'a,'bs/$/\\=INC(5)/\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" generate a list of numbers  23-64\r\n\
  o23<ESC>qqYp<C-A>q40@q\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" editing/moving within current insert (Really useful)\r\n\
  <C-U>                             : delete all entered\r\n\
  <C-W>                             : delete last word\r\n\
  <HOME><END>                       : beginning/end of line\r\n\
  <C-LEFTARROW><C-RIGHTARROW>       : jump one word backwards/forwards\r\n\
  <C-X><C-E>,<C-X><C-Y>             : scroll while staying put in insert\r\n\
  ----------------------------------------\r\n\
  #encryption (use with care: DON'T FORGET your KEY)\r\n\
  :X                                : you will be prompted for a key\r\n\
  :h :X\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" modeline (make a file readonly etc) must be in first/last 5 lines\r\n\
  // vim:noai:ts=2:sw=4:readonly:\r\n\
  \r\n\
  \" vim:ft=html:                    : says use HTML Syntax highlighting\r\n\
  :h modeline\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Creating your own GUI Toolbar entry\r\n\
  amenu  Modeline.Insert\\ a\\ VIM\\ modeline <Esc><Esc>ggOvim:ff=unix ts=4 ss=4<CR>vim60:fdm=marker<esc>gg\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" A function to save word under cursor to a file\r\n\
  function! SaveWord()\r\n   normal yiw\r\n   exe ':!echo '.@0.' >> word.txt'\r\n\
  endfunction\r\n\
  map ,p :call SaveWord()\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" function to delete duplicate lines\r\n\
  function! Del()\r\n if getline(\".\") == getline(line(\".\") - 1)\r\n   norm dd\r\n endif\r\n\
  endfunction\r\n\
  \r\n\
  :g/^/ call Del()\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Digraphs (non alpha-numerics)\r\n\
  :digraphs                         : display table\r\n\
  :h dig                            : help\r\n\
  i<C-K>e'                          : enters \xC3\xA9\r\n\
  i<C-V>233                         : enters \xC3\xA9 (Unix)\r\n\
  i<C-Q>233                         : enters \xC3\xA9 (Win32)\r\n\
  ga                                : View hex value of any character\r\n\
  #Deleting non-ascii characters (some invisible)\r\n\
  :%s/[\\x00-\\x1f\\x80-\\xff]/ /g      : type this as you see it\r\n\
  :%s/[<C-V>128-<C-V>255]//gi       : where you have to type the Control-V\r\n\
  :%s/[\xE2\x82\xAC-\xC3\xBF]//gi                     : Should see a black square & a dotted y\r\n\
  :%s/[<C-V>128-<C-V>255<C-V>01-<C-V>31]//gi : All pesky non-asciis\r\n\
  :exec \"norm /[\\x00-\\x1f\\x80-\\xff]/\"        : same thing\r\n\
  #Pull a non-ascii character onto search bar\r\n\
  yl/<C-R>\"                         :\r\n\
  /[^a-zA-Z0-9_[:space:][:punct:]]  : search for all non-ascii\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" All file completions grouped (for example main_c.c)\r\n\
  :e main_<tab>                     : tab completes\r\n\
  gf                                : open file under cursor  (normal)\r\n\
  main_<C-X><C-F>                   : include NAME of file in text (insert mode)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Complex Vim\r\n\
  \r\n\
  \" swap two words\r\n\
  :%s/\\<\\(on\\|off\\)\\>/\\=strpart(\"offon\", 3 * (\"off\" == submatch(0)), 3)/g\r\n\
  \r\n\
  \" swap two words\r\n\
  :vnoremap <C-X> <Esc>`.``gvP``P\r\n\
  \r\n\
  \" Swap word with next word\r\n\
  nmap <silent> gw    \"_yiw:s/\\(\\%#\\w\\+\\)\\(\\_W\\+\\)\\(\\w\\+\\)/\\3\\2\\1/<cr><c-o><c-l> \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Convert Text File to HTML\r\n\
  :runtime! syntax/2html.vim        : convert txt to html\r\n\
  :h 2html\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" VIM has internal grep\r\n\
  :grep some_keyword *.c            : get list of all c-files containing keyword\r\n\
  :cn                               : go to next occurrence\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Force Syntax coloring for a file that has no extension .pl\r\n\
  :set syntax=perl\r\n\
  \r\n\
  \" Remove syntax coloring (useful for all sorts of reasons)\r\n\
  :set syntax off\r\n\
  \r\n\
  \" change coloring scheme (any file in ~vim/vim??/colors)\r\n\
  :colorscheme blue\r\n\
  \r\n\
  \" Force HTML Syntax highlighting by using a modeline\r\n\
  # vim:ft=html:\r\n\
  \r\n\
  \" Force syntax automatically (for a file with non-standard extension)\r\n\
  au BufRead,BufNewFile */Content.IE?/* setfiletype html\r\n\
  ----------------------------------------\r\n\
  :set noma (non modifiable)        : Prevents modifications\r\n\
  :set ro (Read Only)               : Protect a file from unintentional writes\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Sessions (Open a set of files)\r\n\
  gvim file1.c file2.c lib/lib.h lib/lib2.h : load files for \"session\"\r\n\
  :mksession                        : Make a Session file (default Session.vim)\r\n\
  :q\r\n\
  gvim -S Session.vim               : Reload all files\r\n\
  ----------------------------------------\r\n\
  #tags (jumping to subroutines/functions)\r\n\
  taglist.vim                       : popular plugin\r\n\
  :Tlist                            : display Tags (list of functions)\r\n\
  <C-]>                             : jump to function under cursor\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" columnise a csv file for display only as may crop wide columns\r\n\
  :let width = 20\r\n\
  :let fill=' ' | while strlen(fill) < width | let fill=fill.fill | endwhile\r\n\
  :%s/\\([^;]*\\);\\=/\\=strpart(submatch(1).fill, 0, width)/ge\r\n\
  :%s/\\s\\+$//ge\r\n\
  \r\n\
  \" Highlight a particular csv column (put in .vimrc)\r\n\
  function! CSVH(x)\r\n    execute 'match Keyword /^\\([^,]*,\\)\\{'.a:x.'}\\zs[^,]*/'\r\n    execute 'normal ^'.a:x.'f,'\r\n\
  endfunction\r\n\
  command! -nargs=1 Csv :call CSVH(<args>)\r\n\
  \r\n\
  \" call with\r\n\
  :Csv 5                             : highlight fifth column\r\n\
  ----------------------------------------\r\n\
  zf1G      : fold everything before this line \r\n\
  \r\n\
  \" folding : hide sections to allow easier comparisons\r\n\
  zf}                               : fold paragraph using motion\r\n\
  v}zf                              : fold paragraph using visual\r\n\
  zf'a                              : fold to mark\r\n\
  zo                                : open fold\r\n\
  zc                                : re-close fold\r\n\
  :help folding\r\n\
  zfG      : fold everything after this line \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" displaying \"non-asciis\"\r\n\
  :set list\r\n\
  :h listchars\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" How to paste \"normal commands\" w/o entering insert mode\r\n\
  :norm qqy$jq\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" manipulating file names\r\n\
  :h filename-modifiers             : help\r\n\
  :w %                              : write to current file name\r\n\
  :w %:r.cfm                        : change file extention to .cfm\r\n\
  :!echo %:p                        : full path & file name\r\n\
  :!echo %:p:h                      : full path only\r\n\
  :!echo %:t                        : filename only\r\n\
  :reg %                            : display filename\r\n\
  <C-R>%                            : insert filename (insert mode)\r\n\
  \r\n\
  \"%p                               : insert filename (normal mode)\r\n\
  /<C-R>%                           : Search for file name in text\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" delete without destroying default buffer contents\r\n\
  \r\n\
  \"_d                               : what you've ALWAYS wanted\r\n\
  \r\n\
  \"_dw                              : eg delete word (use blackhole)\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" pull full path name into paste buffer for attachment to email etc\r\n\
  nnoremap <F2> :let @*=expand(\"%:p\")<cr> :unix\r\n\
  nnoremap <F2> :let @*=substitute(expand(\"%:p\"), \"/\", \"\\\\\", \"g\")<cr> :win32\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Simple Shell script to rename files w/o leaving vim\r\n\
  $ vim\r\n\
  :r! ls *.c\r\n\
  :%s/\\(.*\\).c/mv & \\1.bla\r\n\
  :w !sh\r\n\
  :q!\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" count words/lines in a text file\r\n\
  g<C-G>                                 # counts words\r\n\
  :echo line(\"'b\")-line(\"'a\")            # count lines between markers a and b \r\n\
  :'a,'bs/^//n                           # count lines between markers a and b\r\n\
  :'a,'bs/somestring//gn                 # count occurences of a string\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" example of setting your own highlighting\r\n\
  :syn match DoubleSpace \"  \"\r\n\
  :hi def DoubleSpace guibg=#e0e0e0\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" reproduce previous line word by word\r\n\
  imap ]  @@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s\r\n\
  nmap ] i@@@<ESC>hhkyWjl?@@@<CR>P/@@@<CR>3s\r\n\
  \r\n\
  \" Programming keys depending on file type\r\n\
  :autocmd bufenter *.tex map <F1> :!latex %<CR>\r\n\
  :autocmd bufenter *.tex map <F2> :!xdvi -hush %<.dvi&<CR>\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" reading Ms-Word documents, requires antiword\r\n\
  :autocmd BufReadPre *.doc set ro\r\n\
  :autocmd BufReadPre *.doc set hlsearch!\r\n\
  :autocmd BufReadPost *.doc %!antiword \"%\"\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" a folding method\r\n\
  vim: filetype=help foldmethod=marker foldmarker=<<<,>>>\r\n\
  A really big section closed with a tag <<< \r\n\
  --- remember folds can be nested --- \r\n\
  Closing tag >>> \r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Return to last edit position (You want this!) \r\n\
  autocmd BufReadPost *\r\n     \\ if line(\"'\\\"\") > 0 && line(\"'\\\"\") <= line(\"$\") |\r\n     \\   exe \"normal! g`\\\"\" |\r\n     \\ endif\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" store text that is to be changed or deleted in register a\r\n\
  \r\n\
  \"act<                                 :  Change Till < \r\n\
  ----------------------------------------\r\n\
  # using gVIM with Cygwin on a Windows PC\r\n\
  if has('win32')\r\n\
  source $VIMRUNTIME/mswin.vim\r\n\
  behave mswin\r\n\
  set shell=c:\\\\cygwin\\\\bin\\\\bash.exe shellcmdflag=-c shellxquote=\\\"\r\n\
  endif\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \" Just Another Vim Hacker JAVH\r\n\
  vim -c \":%s%s*%Cyrnfr)fcbafbe[Oenz(Zbbyranne%|:%s)[[()])-)Ig|norm Vg?\"\r\n\
  ----------------------------------------\r\n\
  __END__\r\n\
  ----------------------------------------\r\n\
  \r\n\
  \"Read Vimtips into a new vim buffer (needs w3m.sourceforge.net)\r\n\
  :tabe | :r ! w3m -dump http://zzapper.co.uk/vimtips.html    \r\n\
  ----------------------------------------\r\n\
  updated version at http://www.zzapper.co.uk/vimtips.html"
